#ifndef BUILD_LK
#include <linux/string.h>
#include <linux/kernel.h>
#endif

#include "lcm_drv.h"

// ---------------------------------------------------------------------------
//  Local Constants
// ---------------------------------------------------------------------------
#define FRAME_WIDTH  										(480)
#define FRAME_HEIGHT 										(800)
#define REGFLAG_DELAY             							0xFFE
#define REGFLAG_END_OF_TABLE      							0xFFF   // END OF REGISTERS MARKER
#define LCM_DSI_CMD_MODE									0

#define GC9503V_LCM_ID       (0x9504)
#ifndef TRUE
    #define   TRUE     1
#endif
 
#ifndef FALSE
    #define   FALSE    0
#endif
// ---------------------------------------------------------------------------
//  Local Variables
// ---------------------------------------------------------------------------

static struct LCM_UTIL_FUNCS lcm_util;
#define SET_RESET_PIN(v)    								(lcm_util.set_reset_pin((v)))
#define UDELAY(n) 											(lcm_util.udelay(n))
#define MDELAY(n) 											(lcm_util.mdelay(n))
//extern void app_get_rgt_lcm_name(char *name);
// ---------------------------------------------------------------------------
//  Local Functions
// ---------------------------------------------------------------------------

#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
#define read_reg_v2(cmd, buffer, buffer_size)   				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)         
//extern void app_get_rgt_lcm_name(char *name);

struct LCM_setting_table {
    unsigned cmd;
    unsigned char count;
    unsigned char para_list[80];
};

//unsigned int vcomdata=0x30;
static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
{
	unsigned int i;

    for(i = 0; i < count; i++)
    {
        unsigned cmd;
        cmd = table[i].cmd;
		
        switch (cmd)
        {
		//	case 0xBE:
		//	table[i].para_list[1]=vcomdata;
		//	dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
		//	vcomdata+=2;
		//	break;
			
            case REGFLAG_DELAY :
                MDELAY(table[i].count);
                break;
				
            case REGFLAG_END_OF_TABLE :
                break;
				
            default:
				dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
       	}
    }
	
}

static struct LCM_setting_table lcm_initialization_setting[] = {
// GC9503V HSD
	{0xF0,5,{0x55,0xAA,0x52,0x08,0x00}},
	{0xF6,2,{0x5A,0x87}},
	{0xC1,1,{0x3F}},
	{0xC2,1,{0x0E}},
	{0xC6,1,{0xF8}},
	{0xC9,1,{0x10}},
	{0xCD,1,{0x25}},
	{0xF8,1,{0x8A}},
	{0xAC,1,{0x45}},
	{0xA0,1,{0xbb}},
	{0xA7,1,{0x47}},
	{0xFA,4,{0x0F,0x0F,0x00,0x04}},
	{0xA3,1,{0xEE}},
	{0xFD,3,{0x28,0x28,0x00}},
	{0x71,1,{0x48}},
	{0x72,1,{0x48}},
	{0x73,2,{0x00,0x44}},
	{0x97,1,{0xEE}},
	{0x83,1,{0x93}},
	{0x86,4,{0x99,0xe3,0xe3,0x35}},
	{0x9A,1,{0x90}},
	{0x9B,1,{0xC4}},
	{0x82,2,{0x73,0x73}},
	{0xB1,1,{0x90}},
	{0x6D,32,{0x00,0x1F,0x19,0x1A,0x0C,0x0A,0x10,0x0E,0x02,0x08,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x07,0x01,0x0D,0x0F,0x09,0x0B,0x1A,0x19,0x1F,0x00}},
	{0x64,16,{0x38,0x08,0x03,0x20,0x03,0x03,0x38,0x07,0x03,0x21,0x03,0x03,0x0A,0x7A,0x0A,0x7A}},
	{0x65,16,{0x38,0x06,0x03,0x22,0x03,0x03,0x38,0x05,0x03,0x23,0x03,0x03,0x0A,0x7A,0x0A,0x7A}},
	{0x66,16,{0x38,0x04,0x03,0x24,0x03,0x03,0x38,0x03,0x03,0x25,0x03,0x03,0x0A,0x7A,0x0A,0x7A}},	
	{0x67,16,{0x38,0x02,0x03,0x26,0x03,0x03,0x38,0x01,0x03,0x27,0x03,0x03,0x0A,0x7A,0x0A,0x7A}},	
	{0x68,13,{0x3B,0x08,0x1B,0x08,0x1B,0x60,0x70,0x08,0x1B,0x08,0x1B,0x60,0x70}},			
	{0x60,8,{0x38,0x0C,0x08,0x7A,0x38,0x0B,0x08,0x7A}},
	{0x61,8,{0x18,0x00,0x7A,0x7A,0x18,0x00,0x7A,0x7A}},
	{0x62,8,{0x18,0x00,0x7A,0x7A,0x18,0x00,0x7A,0x7A}},
	{0x63,8,{0x38,0x0A,0x08,0x7A,0x38,0x09,0x08,0x7A}},		
	{0x69,7,{0x01,0x11,0x01,0x11,0x01,0x11,0x08}},
	{0x6B,1,{0x07}},
	{0x7A,2,{0x08,0x13}},
	{0x7B,2,{0x08,0x13}},
	{0xD1,52,{0x00,0x00,0x00,0x05,0x00,0x10,0x00,0x1A,0x00,0x20,0x00,0x30,0x00,0x3B,0x00,0x55,0x00,0x68,0x00,0x86,0x00,0xBA,0x01,0x2E,0x01,0x8D,0x01,0x8E,0x01,0xE5,0x02,0x46,0x02,0xA0,0x03,0x00,0x03,0x30,0x03,0x72,0x03,0x98,0x03,0xCA,0x03,0xE0,0x03,0xF5,0x03,0xFD,0x03,0xFF}},
	{0xD2,52,{0x00,0x00,0x00,0x05,0x00,0x10,0x00,0x1A,0x00,0x20,0x00,0x30,0x00,0x3B,0x00,0x55,0x00,0x68,0x00,0x86,0x00,0xBA,0x01,0x2E,0x01,0x8D,0x01,0x8E,0x01,0xE5,0x02,0x46,0x02,0xA0,0x03,0x00,0x03,0x30,0x03,0x72,0x03,0x98,0x03,0xCA,0x03,0xE0,0x03,0xF5,0x03,0xFD,0x03,0xFF}},
	{0xD3,52,{0x00,0x00,0x00,0x05,0x00,0x10,0x00,0x1A,0x00,0x20,0x00,0x30,0x00,0x3B,0x00,0x55,0x00,0x68,0x00,0x86,0x00,0xBA,0x01,0x2E,0x01,0x8D,0x01,0x8E,0x01,0xE5,0x02,0x46,0x02,0xA0,0x03,0x00,0x03,0x30,0x03,0x72,0x03,0x98,0x03,0xCA,0x03,0xE0,0x03,0xF5,0x03,0xFD,0x03,0xFF}},
	{0xD4,52,{0x00,0x00,0x00,0x05,0x00,0x10,0x00,0x1A,0x00,0x20,0x00,0x30,0x00,0x3B,0x00,0x55,0x00,0x68,0x00,0x86,0x00,0xBA,0x01,0x2E,0x01,0x8D,0x01,0x8E,0x01,0xE5,0x02,0x46,0x02,0xA0,0x03,0x00,0x03,0x30,0x03,0x72,0x03,0x98,0x03,0xCA,0x03,0xE0,0x03,0xF5,0x03,0xFD,0x03,0xFF}},
	{0xD5,52,{0x00,0x00,0x00,0x05,0x00,0x10,0x00,0x1A,0x00,0x20,0x00,0x30,0x00,0x3B,0x00,0x55,0x00,0x68,0x00,0x86,0x00,0xBA,0x01,0x2E,0x01,0x8D,0x01,0x8E,0x01,0xE5,0x02,0x46,0x02,0xA0,0x03,0x00,0x03,0x30,0x03,0x72,0x03,0x98,0x03,0xCA,0x03,0xE0,0x03,0xF5,0x03,0xFD,0x03,0xFF}},
	{0xD6,52,{0x00,0x00,0x00,0x05,0x00,0x10,0x00,0x1A,0x00,0x20,0x00,0x30,0x00,0x3B,0x00,0x55,0x00,0x68,0x00,0x86,0x00,0xBA,0x01,0x2E,0x01,0x8D,0x01,0x8E,0x01,0xE5,0x02,0x46,0x02,0xA0,0x03,0x00,0x03,0x30,0x03,0x72,0x03,0x98,0x03,0xCA,0x03,0xE0,0x03,0xF5,0x03,0xFD,0x03,0xFF}},

	{0x11, 0,{0x00}},
	{REGFLAG_DELAY, 120, {}}, 
	{0x29, 0,{0x00}},

	{REGFLAG_DELAY, 100, {}}, 
	{REGFLAG_END_OF_TABLE, 0x00, {}}


};

//int vcom=0x90;
static void init_lcm_registers(void)
{
#if 0
unsigned int data_array[16];


data_array[0]= 0x00043902;
data_array[1]= 0xF26191BF;
dsi_set_cmdq(&data_array, 2, 1);
MDELAY(1);

data_array[0] = 0x00110500;	//exit sleep mode
dsi_set_cmdq(&data_array, 1, 1);
MDELAY(150);

data_array[0] = 0x00290500;	//Display on
dsi_set_cmdq(&data_array, 1, 1);
MDELAY(20);	
#else

push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);

#endif  	
}

static struct LCM_setting_table lcm_deep_sleep_mode_in_setting[] = {
	// 
	{0xF0,5,{0x55,0xaa,0x52,0x08,0x00}}, // 20200403   james 	
	{0xc1, 1,{0x3f}},  // reg en 6c	20200403	james
	{0x6C, 1,{0x60}},
	{REGFLAG_DELAY, 20, {}},
	{0xB1, 1,{0x00}},
	{0xFA, 4,{0x7F, 0x00, 0x00, 0x00}},
	{REGFLAG_DELAY, 20, {}},
	{0x6c,1,{0x50}}, 
	{REGFLAG_DELAY, 10, {}},

	{0x28, 0,{0x00}},   
	{REGFLAG_DELAY, 50, {}},  
	{0x10, 0,{0x00}},
	{REGFLAG_DELAY, 20, {}},

	//
	{0xF0,5,{0x55,0xaa,0x52,0x08,0x00}},
	{0xc2,1,{0xce}},
	{0xc3,1,{0xcd}},
	{0xc6,1,{0xfc}},
	{0xc5,1,{0x03}},
	{0xcd,1,{0x64}},
	{0xc4,1,{0xff}},///REG85 EN

	{0xc9,1,{0xcd}},
	{0xF6,2,{0x5a,0x87}},
	{0xFd,3,{0xaa,0xaa, 0x0a}},
	{0xFe,2,{0x6a,0x0a}},
	{0x78,2,{0x2a,0xaa}},
	{0x92,2,{0x17,0x08}},
	{0x77,2,{0xaa,0x2a}},
	{0x76,2,{0xaa,0xaa}},
	{0x84,1,{0x00}},
	{0x78,2,{0x2b,0xba}},
	{0x89,1,{0x73}},
	{0x88,1,{0x3A}},
	{0x85,1,{0xB0}},
	{0x76,2,{0xeb,0xaa}},
	{0x94,1,{0x80}},
	{0x87,3,{0x04,0x07,0x30}},				   
	{0x93,1,{0x27}},
	{0xaf,1,{0x02}},

	{REGFLAG_END_OF_TABLE, 0x00, {}}
};
// ---------------------------------------------------------------------------
//  LCM Driver Implementations
// ---------------------------------------------------------------------------
// GC9503V_GIP_CLK_ON_OFF_CTRL
/*
static struct LCM_setting_table lcm_gip_reload_tyc[] = {

    {0xF0,5,{0x55,0xaa,0x52,0x08,0x00}},	 
    {0x6C, 1,{0x01}},
	{REGFLAG_END_OF_TABLE, 0x00, {}}

};
*/
static void lcm_set_util_funcs(const struct LCM_UTIL_FUNCS *util)
{
	memcpy(&lcm_util, util, sizeof(struct LCM_UTIL_FUNCS));
}


static void lcm_get_params(struct LCM_PARAMS *params)
{
	memset(params, 0, sizeof(struct LCM_PARAMS));

	params->type = LCM_TYPE_DSI;

	params->width  = FRAME_WIDTH;
	params->height = FRAME_HEIGHT;

    #if (LCM_DSI_CMD_MODE)
	params->dsi.mode   = CMD_MODE;
    #else

    params->dsi.mode   =SYNC_PULSE_VDO_MODE;//SYNC_PULSE_VDO_MODE;//SYNC_EVENT_VDO_MODE;
    #endif
	
	// DSI
	/* Command mode setting */
	params->dsi.LANE_NUM				= LCM_TWO_LANE;
		
	//The following defined the fomat for data coming from LCD engine.
    params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
	params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
	params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
	params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;

	// Highly depends on LCD driver capability.
	// Not support in MT6573
	params->dsi.packet_size=256;

    // Video mode setting
    params->dsi.intermediat_buffer_num = 2;

	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
	params->dsi.word_count= FRAME_WIDTH * 3;	

	params->dsi.vertical_sync_active				= 10; 
	params->dsi.vertical_backporch					= 40; 
	params->dsi.vertical_frontporch					= 40; 
	params->dsi.vertical_active_line				= FRAME_HEIGHT; 

	params->dsi.horizontal_sync_active				= 10;	//2;
	params->dsi.horizontal_backporch				= 50;//120;	//60;	//42;
	params->dsi.horizontal_frontporch				= 50;		//		6;//100;	//60;	//44;
//	params->dsi.horizontal_blanking_pixel			= 60;//60
	params->dsi.horizontal_active_pixel				= FRAME_WIDTH;
	params->dsi.cont_clock = TRUE;

	// ESD
	params->dsi.esd_check_enable = 0;
	params->dsi.customization_esd_check_enable = 1;
	params->dsi.lcm_esd_check_table[0].cmd = 0x0A;
	params->dsi.lcm_esd_check_table[0].count = 1;
	params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9C;

	params->dsi.PLL_CLOCK =200;// 210 215 205 225
//	params->dsi.ssc_disable        = 0;
 // params->dsi.ssc_range  = 6;
		
}

static void lcm_suspend(void)
{
	push_table(lcm_deep_sleep_mode_in_setting, sizeof(lcm_deep_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);
    SET_RESET_PIN(1);
    MDELAY(10);

}
// GC9503V_GIP_CLK_ON_OFF_CTRL
/*
void gc5035_lcm_reload_tyc(void)
{ 
    printk("yqf: gc9503 %s %d\n", __func__,__LINE__);
	push_table(lcm_gip_reload_tyc, sizeof(lcm_gip_reload_tyc) / sizeof(struct LCM_setting_table), 1);

}   */

static unsigned int lcm_compare_id(void)
{
    int array[4];
    char buffer[4];
    int id=0;
	//unsigned char lcm_read = 0;
//return 1;
    SET_RESET_PIN(1);
    MDELAY(10);
	SET_RESET_PIN(0);
    MDELAY(25);
	SET_RESET_PIN(1);
    MDELAY(120);

    array[0] = 0x00033700;// read id return two byte,version and id
    dsi_set_cmdq(array, 1, 1);
    read_reg_v2(0x04,buffer, 3);

//	mt_set_gpio_mode(ST_LCM_ID_PIN, GPIO_MODE_00);
//	mt_set_gpio_dir(ST_LCM_ID_PIN, GPIO_DIR_IN);
//	lcm_read = mt_get_gpio_in(ST_LCM_ID_PIN);
    id = (buffer[1] << 8) | buffer[2]; 

    #ifdef BUILD_LK
    printf("yqf uboot: gc9503 %s %d, id = 0x%08x\n", __func__,__LINE__, id);
    #else
    printk("yqf: gc9503 %s %d, id = 0x%08x\n", __func__,__LINE__, id);
    #endif
    //return ((id == 0x8802) && (lcm_read == 0)) ?1:0;
	return ((GC9503V_LCM_ID == id) ? 1:0);  
	
} 

static void lcm_init(void)
{	

    SET_RESET_PIN(1);
	MDELAY(10);
    SET_RESET_PIN(0);
    MDELAY(10);
    SET_RESET_PIN(1);
    MDELAY(100);
    init_lcm_registers();
	//lcm_compare_id();
}

static void lcm_resume(void)
{
// lcm_initialization_setting[9].para_list[0]+=2;
// lcm_initialization_setting[11].para_list[0]+=2;

	lcm_init();
	//app_get_rgt_lcm_name("gc9503_hsd");

    //init_lcm_registers();
	//push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
}

// ---------------------------------------------------------------------------
//  Get LCM Driver Hooks
// ---------------------------------------------------------------------------
struct LCM_DRIVER gc9503v_dsi_vdo_wvga_m31_byd_hsd_lcm_drv = 
{
    .name = "gc9503v_dsi_vdo_wvga_m31_byd_hsd",
    .set_util_funcs = lcm_set_util_funcs,
	.get_params     = lcm_get_params,
	.init           = lcm_init,
	.suspend        = lcm_suspend,
	.resume         = lcm_resume,
	.compare_id    = lcm_compare_id,
#if (LCM_DSI_CMD_MODE)
    .update         = lcm_update,
#endif
};


